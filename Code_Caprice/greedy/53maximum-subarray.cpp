/*
53. 最大子数组和
中等
相关标签
premium lock icon
相关企业
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组是数组中的一个连续部分。

示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：
输入：nums = [1]
输出：1

示例 3：
输入：nums = [5,4,-1,7,8]
输出：23

提示：
1 <= nums.length <= 105
-104 <= nums[i] <= 104
*/
#include <cstdint>
#include <vector>
using namespace std;

int maxSubArray(vector<int>& nums) {
    int count = 0;
    int result = INT32_MIN; // 处理全负数组的情况
    for(int i = 0;i<nums.size();i++){
        count += nums[i];
        if(count > result){
            result = count; // 随时记录最优解
        }
        if(count <= 0) count = 0;
    }
    return result;
}
/*

这题贪心的核心就是，以当前的子序和为视角，每次选择时都可能让子序和更大：
当子序和负数时，替换新子序和，因为无论如何加下一个数都不如直接选下一个数成为新子序和大
当子序和正数时，直接加新数字，因为无论如何替换下一个数都不如当前子序和加数字大

很经典地体现了 “贪” 的特点，目标就是要让子序和尽可能大！

nums = [-2,1,-3,4,-1,2,1,-5,4]
### 第一步：从 -2 开始
```
当前位置: -2
累积和: -2
思考: 以-2开头的任何子数组，都相当于给后面的数"减去2"
      既然-2只会使后面的数的和小,那么为什么我们不抛弃这个-2,然后尽可能保证后面的数的和大呢? 
      比如[-2,1] = -1，而单独[1] = 1
      显然1 > -1，所以我们应该抛弃-2！
```

### 第二步：从 1 开始重新计算
```
当前位置: 1
累积和: 1 (抛弃了前面的-2)

更新最大值: result = 1
```

### 第三步：继续到 -3
```
当前位置: -3
累积和: 1 + (-3) = -2
思考: 现在累积和又变成负数了！
      这意味着[1,-3]这个组合对后续数字是负贡献
      我们应该再次抛弃！
```

### 第四步：从 4 开始重新计算
```
当前位置: 4
累积和: 4 (重新开始)
更新最大值: result = 4
```

### 继续执行...
```
位置: -1, 累积和: 4 + (-1) = 3
位置: 2,  累积和: 3 + 2 = 5
位置: 1,  累积和: 5 + 1 = 6  <- 更新最大值!
位置: -5, 累积和: 6 + (-5) = 1
位置: 4,  累积和: 1 + 4 = 5
```

## 关键洞察：负数累积的"传染性" 🦠

你的思考抓住了核心：**负数累积具有"传染性"**

```cpp
// 假设我们不抛弃负数累积
// 对于任何后续的正数 x：
累积和 + x = (负数) + x < x

// 这意味着：
// 包含负数累积的子数组和 < 不包含负数累积的子数组和
```
      
*/

int main(){}

