/*
343. 整数拆分
*/
#include <vector>
using namespace std;
#include <iostream>

/**
 * @brief 整数拆分函数
 *
 * 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。
 * 返回你可以获得的最大的乘积。
 *
 * @param n 需要拆分的正整数。
 * @return 拆分后得到的最大乘积。
 *
 * @details 采用动态规划的方法解决此问题。
 * dp[i] 表示将正整数 i 拆分成至少两个正整数的和后，这些整数的最大乘积。
 *
 * 初始化:
 * dp[0] = 0 (通常不使用，但为了数组大小一致性)
 * dp[1] = 0 (1 不能拆分出至少两个正整数)
 * dp[2] = 1 (2 只能拆分成 1 + 1，乘积为 1*1 = 1)
 *
 * 状态转移方程:
 * dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
 * 这里的 j 从 1 遍历到 i/2。
 *
 * j * (i - j) 表示将 i 拆分为 j 和 (i - j) 两个数，然后直接相乘。
 * j * dp[i - j] 表示将 i 拆分为 j 和 (i - j)，但是 (i - j) 这个数可以继续拆分，
 * 此时取 dp[i - j] 的最大乘积值。
 * 我们需要比较这两种情况，并取较大值，同时与当前的 dp[i] (可能已被前面的 j
 * 更新过) 比较， 以确保 dp[i] 始终存储的是最大的乘积。
 */
int integerBreak(int n) {
    // dp[i] 表示将正整数 i 拆分成至少两个正整数的和后，这些整数的最大乘积。
    vector<int> dp(n + 1);
    // 2 只能拆分成 1 + 1，乘积为 1*1 = 1。这是动态规划的起始点。
    dp[2] = 1;
    // 从 i = 3 开始遍历到 n，计算每个 i 的最大乘积
    for (int i = 3; i < n + 1; i++) {
        // j 从 1 遍历到 i/2。
        // 因为 i 拆分成 j 和 (i-j) 与拆分成 (i-j) 和 j 是一样的，
        // 遍历到 i/2 可以避免重复计算，并保证 j <= i-j。
        for (int j = 1; j <= i / 2; j++) {
            // dp[i] = max(当前 dp[i] 的值, max(直接相乘, 拆分一部分后继续拆分))
            // j * (i - j): 表示将 i 拆分为 j 和 (i - j)，直接相乘得到的结果。
            // j * dp[i - j]: 表示将 i 拆分为 j 和 (i - j)，但 (i - j)
            // 可以继续拆分，
            //                 并取 (i - j) 拆分后的最大乘积 (即 dp[i - j])。
            // 比较这两种情况以及当前 dp[i] 的值，取三者中的最大值。
            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
        }
    }
    // 返回 n 拆分后的最大乘积
    return dp.back();
}

int main() {
    int result = integerBreak(10);
    std::cout << "result: " << result << std::endl;
}