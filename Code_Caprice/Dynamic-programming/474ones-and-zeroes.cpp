/*
474. 一和零
中等
相关标签
premium lock icon
相关企业
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4
。 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"}
不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

思路：相当于背包问题，背包的容量是两个维度
dp[i][j] 代表了这个最多能装i个0和j个1的背包最多能放多少个元素。

示例 2：

输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。


提示：

1 <= strs.length <= 600
1 <= strs[i].length <= 100
strs[i] 仅由 '0' 和 '1' 组成
1 <= m, n <= 100
*/

#include <string>
#include <vector>
using namespace std;
#include <iostream>

/**
 * @brief 找出并返回 strs 的最大子集的长度，该子集中最多有 m 个 0 和 n 个 1。
 * 这个问题可以被抽象为多维背包问题，其中背包的容量由 0 的数量 m 和 1 的数量 n
 * 构成， 物品是字符串，每个字符串的"重量"是其包含的 0 和 1 的数量， 价值是
 * 1（因为我们是统计子集的长度，每个字符串算作一个元素）。
 *
 * @param strs 包含二进制字符串的向量。
 * @param m 背包中最多允许的 0 的数量。
 * @param n 背包中最多允许的 1 的数量。
 * @return int 满足条件的最大子集的长度。
 */
int findMaxForm(vector<string> &strs, int m, int n) {
    // dp[i][j] 定义为：当背包容量为 i 个 0 和 j 个 1
    // 时，最多能放入的字符串数量。 初始化为 0，表示在没有字符串或者背包容量为 0
    // 时，能放入的字符串数量为 0。
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    // 遍历每一个字符串，将其视为一个"物品"。
    for (string str : strs) {
        int zero_num = 0, one_num = 0;
        // 统计当前字符串中 0 和 1 的数量。
        for (char s : str) {
            if (s == '0')
                zero_num++;
            else
                one_num++;
        }
        // 动态规划的核心部分：从后往前遍历背包容量。
        // 这是为了避免重复使用同一个字符串（每个字符串只能用一次）。
        // 如果从前往后遍历，dp[i][j] 可能会在计算时重复加上当前字符串的价值。
        for (int i = m; i >= zero_num;
             i--) { // 遍历 0 的容量，从最大容量 m 开始递减。
            for (int j = n; j >= one_num;
                 j--) { // 遍历 1 的容量，从最大容量 n 开始递减。
                // dp[i][j] 的状态转移方程：
                // 1. 不选择当前字符串：dp[i][j]
                // 保持原值（即在考虑当前字符串之前的最大值）。
                // 2. 选择当前字符串：需要消耗 zero_num 个 0 和 one_num 个 1，
                //    此时背包剩余容量为 (i - zero_num, j - one_num)，
                //    再加上当前字符串的价值 1。
                // 取两者中的最大值。
                dp[i][j] = max(dp[i][j], dp[i - zero_num][j - one_num] + 1);
            }
        }
    }
    // 最终 dp[m][n] 即为在最多 m 个 0 和 n 个 1
    // 的限制下，能组成的最大子集长度。
    return dp[m][n];
}

/**
 * @brief 主函数，用于测试 findMaxForm 函数。
 * 初始化一个字符串向量和 0、1 的限制，然后调用 findMaxForm 并打印结果。
 *
 * @return int 程序退出码，0 表示成功。
 */
int main() {
    vector<string> strs = {"10", "0001", "111001", "1", "0"};
    // 调用 findMaxForm 函数，传入字符串数组、m（0 的数量限制）和 n（1
    // 的数量限制）。
    std::cout << findMaxForm(strs, 5, 3) << std::endl;
}
